<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Animation Test - Chatooly CDN</title>
    
    <!-- Load Chatooly CSS for proper styling -->
    <link rel="stylesheet" href="https://yaelren.github.io/chatooly-cdn/css/unified.min.css">
    
    <style>
        .status-info {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            color: var(--text-secondary);
            max-height: 120px;
            overflow-y: auto;
        }
        
        canvas {
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
        }
        
        button {
            margin: 2px;
            font-size: 12px;
            padding: 6px 12px;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 4px 0;
        }
        
        select {
            width: 100%;
            margin: 4px 0;
        }
        
        span {
            font-size: 12px;
            color: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="chatooly-app-container">
        <!-- Left Panel: Tool Controls -->
        <div class="chatooly-controls-panel">
            <div class="chatooly-controls-header">
                <h1>üé¨ Canvas Animation Test</h1>
                <p>Comprehensive CCapture.js integration testing with HTML5 Canvas</p>
            </div>
            
            <div class="chatooly-controls-content">
                <!-- Animation Controls -->
                <div class="chatooly-control-group">
                    <label>Animation Controls</label>
                    <button onclick="startAnimation()">‚ñ∂Ô∏è Start Animation</button>
                    <button onclick="stopAnimation()">‚è∏Ô∏è Stop Animation</button>
                    <button onclick="resetAnimation()">üîÑ Reset</button>
                </div>
                
                <!-- Animation Settings -->
                <div class="chatooly-control-group">
                    <label for="orb-count">Orb Count</label>
                    <input type="range" id="orb-count" min="3" max="20" value="8" onchange="updateOrbCount(this.value)">
                    <span id="orb-count-display">8</span>
                </div>
                
                <div class="chatooly-control-group">
                    <label for="speed-control">Animation Speed</label>
                    <input type="range" id="speed-control" min="0.5" max="3" step="0.1" value="1" onchange="updateSpeed(this.value)">
                    <span id="speed-display">1x</span>
                </div>
                
                <div class="chatooly-control-group">
                    <label for="background-mode">Background</label>
                    <select id="background-mode" onchange="updateBackground(this.value)">
                        <option value="gradient">Gradient</option>
                        <option value="dark">Dark</option>
                        <option value="transparent">Transparent</option>
                    </select>
                </div>
                
                <!-- Chatooly CDN Tests -->
                <div class="chatooly-control-group">
                    <label>Chatooly CDN Tests</label>
                    <button onclick="testDetection()">üîç Test Animation Detection</button>
                    <button onclick="testExport()">üé• Test Animation Export</button>
                    <button onclick="testCDNIntegration()">‚öôÔ∏è Test CDN Integration</button>
                </div>
                
                <!-- Status Display -->
                <div class="chatooly-control-group">
                    <label>System Status</label>
                    <div id="status-display" class="status-info">Initializing...</div>
                </div>
            </div>
        </div>
        
        <!-- Right Panel: Preview/Canvas Area -->
        <div class="chatooly-preview-panel">
            <div id="chatooly-container">
                <canvas id="chatooly-canvas" width="800" height="600"></canvas>
            </div>
        </div>
    </div>
    
    <!-- Load local CDN for testing -->
    <script src="../js/core.js"></script>
    
    <script>
        const canvas = document.getElementById('chatooly-canvas');
        const ctx = canvas.getContext('2d');
        let animationId;
        let isAnimating = false;
        let time = 0;
        let animationSpeed = 1;
        let backgroundMode = 'gradient';
        
        // Animated elements
        let orbs = [];
        let targetOrbCount = 8;
        
        // Initialize orbs
        function initializeOrbs() {
            orbs = [];
            for (let i = 0; i < targetOrbCount; i++) {
                orbs.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: 15 + Math.random() * 20,
                    color: `hsl(${i * (360 / targetOrbCount)}, 70%, 60%)`,
                    speedX: (Math.random() - 0.5) * 2,
                    speedY: (Math.random() - 0.5) * 2,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }
        
        function drawBackground() {
            switch (backgroundMode) {
                case 'gradient':
                    const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    gradient.addColorStop(0, '#1a1a2e');
                    gradient.addColorStop(1, '#16213e');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    break;
                case 'dark':
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    break;
                case 'transparent':
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    break;
            }
        }
        
        function animate() {
            if (!isAnimating) return;
            
            time += 0.02 * animationSpeed;
            
            // Clear canvas with selected background
            drawBackground();
            
            // Update and draw orbs
            orbs.forEach((orb, index) => {
                // Update position with wave motion
                orb.x += (orb.speedX + Math.sin(time + orb.phase) * 0.5) * animationSpeed;
                orb.y += (orb.speedY + Math.cos(time + orb.phase) * 0.3) * animationSpeed;
                
                // Bounce off walls
                if (orb.x < orb.radius || orb.x > canvas.width - orb.radius) {
                    orb.speedX *= -0.8;
                }
                if (orb.y < orb.radius || orb.y > canvas.height - orb.radius) {
                    orb.speedY *= -0.8;
                }
                
                // Keep in bounds
                orb.x = Math.max(orb.radius, Math.min(canvas.width - orb.radius, orb.x));
                orb.y = Math.max(orb.radius, Math.min(canvas.height - orb.radius, orb.y));
                
                // Pulsing size
                const pulseSize = orb.radius + Math.sin(time * 3 + index) * 5;
                
                // Draw orb with glow
                const gradient = ctx.createRadialGradient(orb.x, orb.y, 0, orb.x, orb.y, pulseSize);
                gradient.addColorStop(0, orb.color);
                gradient.addColorStop(1, 'transparent');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, pulseSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner bright core
                ctx.fillStyle = 'white';
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.arc(orb.x, orb.y, pulseSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
            
            // Draw connecting lines between nearby orbs
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i < orbs.length; i++) {
                for (let j = i + 1; j < orbs.length; j++) {
                    const dx = orbs[i].x - orbs[j].x;
                    const dy = orbs[i].y - orbs[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 150) {
                        ctx.beginPath();
                        ctx.moveTo(orbs[i].x, orbs[i].y);
                        ctx.lineTo(orbs[j].x, orbs[j].y);
                        ctx.stroke();
                    }
                }
            }
            
            // Performance and status info
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '12px Arial';
            ctx.fillText(`Time: ${time.toFixed(2)}s | Speed: ${animationSpeed}x | Orbs: ${orbs.length}`, 10, 20);
            ctx.fillText(`Background: ${backgroundMode} | FPS: ~60`, 10, 40);
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Animation Controls
        function startAnimation() {
            if (isAnimating) return;
            isAnimating = true;
            updateStatus('üé® Canvas animation started');
            animate();
        }
        
        function stopAnimation() {
            isAnimating = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            updateStatus('‚è∏Ô∏è Canvas animation stopped');
        }
        
        function resetAnimation() {
            time = 0;
            initializeOrbs();
            if (!isAnimating) {
                startAnimation();
            }
            updateStatus('üîÑ Animation reset with new orbs');
        }
        
        // UI Controls
        function updateOrbCount(count) {
            targetOrbCount = parseInt(count);
            document.getElementById('orb-count-display').textContent = count;
            initializeOrbs();
            updateStatus(`üî¢ Orb count updated to ${count}`);
        }
        
        function updateSpeed(speed) {
            animationSpeed = parseFloat(speed);
            document.getElementById('speed-display').textContent = speed + 'x';
            updateStatus(`‚ö° Animation speed set to ${speed}x`);
        }
        
        function updateBackground(mode) {
            backgroundMode = mode;
            updateStatus(`üé® Background mode: ${mode}`);
        }
        
        // Chatooly CDN Tests
        function testDetection() {
            updateStatus('üîç Testing animation detection...');
            
            if (!window.Chatooly || !window.Chatooly.animation) {
                updateStatus('‚ùå Chatooly animation module not loaded');
                return;
            }
            
            const toolInfo = window.Chatooly.animation.detectToolType();
            console.log('üîç Detection result:', toolInfo);
            
            if (toolInfo.type === 'animated') {
                updateStatus(`‚úÖ Animation detected: ${toolInfo.framework} framework`);
            } else {
                updateStatus('‚ùå No animation detected - check console for details');
            }
        }
        
        function testExport() {
            if (!window.Chatooly || !window.Chatooly.animation) {
                updateStatus('‚ùå Chatooly animation module not available');
                return;
            }
            
            updateStatus('üé• Opening animation export dialog...');
            
            // Start animation if not running
            if (!isAnimating) {
                startAnimation();
            }
            
            // Show export dialog
            setTimeout(() => {
                window.Chatooly.animation.showExportDialog();
            }, 500);
        }
        
        function testCDNIntegration() {
            updateStatus('‚öôÔ∏è Testing Chatooly CDN integration...');
            
            const tests = [];
            
            // Test 1: CDN Core
            if (window.Chatooly) {
                tests.push('‚úÖ Chatooly core loaded');
                
                // Test 2: Animation module
                if (window.Chatooly.animation) {
                    tests.push('‚úÖ Animation module loaded');
                    
                    // Test 3: Key functions
                    const functions = ['detectToolType', 'showExportDialog', 'loadCCapture'];
                    functions.forEach(fn => {
                        if (typeof window.Chatooly.animation[fn] === 'function') {
                            tests.push(`‚úÖ ${fn}() available`);
                        } else {
                            tests.push(`‚ùå ${fn}() missing`);
                        }
                    });
                } else {
                    tests.push('‚ùå Animation module missing');
                }
            } else {
                tests.push('‚ùå Chatooly core not loaded');
            }
            
            // Test 4: Canvas detection
            const canvas = document.getElementById('chatooly-canvas');
            if (canvas) {
                tests.push('‚úÖ Canvas element found');
            } else {
                tests.push('‚ùå Canvas element missing');
            }
            
            // Test 5: Container detection
            const container = document.getElementById('chatooly-container');
            if (container) {
                tests.push('‚úÖ Container element found');
            } else {
                tests.push('‚ùå Container element missing');
            }
            
            console.log('üß™ CDN Integration Tests:', tests);
            updateStatus(`‚öôÔ∏è Integration test complete - ${tests.filter(t => t.startsWith('‚úÖ')).length}/${tests.length} passed`);
        }
        
        function updateStatus(message) {
            const statusEl = document.getElementById('status-display');
            statusEl.innerHTML = `<span style="color: #4ecdc4;">[${new Date().toLocaleTimeString()}]</span> ${message}`;
        }
        
        // Optional: Time-based animation control for recording
        window.setAnimationTime = function(recordingTime) {
            time = recordingTime * 2; // Speed control during recording
        };
        
        // Initialize
        initializeOrbs();
        
        setTimeout(() => {
            startAnimation();
            
            if (window.Chatooly && window.Chatooly.animation) {
                updateStatus('‚úÖ Chatooly CDN loaded - comprehensive test ready');
                setTimeout(() => testDetection(), 500);
            } else {
                updateStatus('‚ö†Ô∏è Waiting for Chatooly CDN to load...');
                setTimeout(() => {
                    if (window.Chatooly && window.Chatooly.animation) {
                        updateStatus('‚úÖ Chatooly CDN loaded - comprehensive test ready');
                        testDetection();
                    } else {
                        updateStatus('‚ùå Chatooly CDN failed to load - check console');
                    }
                }, 2000);
            }
        }, 1000);
    </script>
</body>
</html>