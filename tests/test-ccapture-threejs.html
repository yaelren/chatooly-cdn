<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CCapture Three.js Animation Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #2b2b2b;
            color: white;
            font-family: 'Lucida Console', Monaco, monospace;
        }
        .controls {
            margin: 20px 0;
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 4px;
        }
        button {
            padding: 8px 15px;
            margin: 3px;
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
        }
        button:hover {
            background: #0056b3;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            background: #333;
            border-left: 4px solid #007bff;
            font-size: 14px;
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            z-index: 1000;
        }
        .info {
            background: #1a1a2e;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            position: absolute;
            top: 10px;
            right: 10px;
            width: 300px;
            z-index: 1000;
        }
        #chatooly-container {
            position: relative;
            z-index: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 600px;
        }
        
        #threejs-container {
            position: relative;
            z-index: 1;
        }
    </style>
</head>
<body>
    <h1>üåü CCapture Three.js Animation Test</h1>
    
    <div class="info">
        <strong>Test Purpose:</strong> Verify CCapture.js integration with Three.js animations
        <br><strong>Framework:</strong> Three.js with automatic render() loop detection
        <br><strong>Canvas ID:</strong> chatooly-canvas (set programmatically)
    </div>
    
    <div class="controls">
        <button onclick="toggleAnimation()">‚è∏Ô∏è Toggle Animation</button>
        <button onclick="testDetection()">üîç Test Detection</button>
        <button onclick="testExport()">üé• Test Export</button>
        <button onclick="toggleWireframe()">üìê Wireframe</button>
        <button onclick="addSphere()">‚ûï Add Sphere</button>
    </div>
    
    <div class="status" id="status">Loading Three.js and Chatooly CDN...</div>
    
    <!-- Required Chatooly container structure -->
    <div id="chatooly-container">
        <div id="threejs-container"></div>
    </div>
    
    <!-- Load Three.js first -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Load local CDN for testing -->
    <script src="../js/core.js"></script>
    
    <script>
        // Three.js scene variables
        let scene, camera, renderer, animationId;
        let spheres = [];
        let animationRunning = true;
        let wireframeMode = false;
        let time = 0;
        
        function initThreeJS() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 10;
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(800, 600);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // IMPORTANT: Set required canvas ID for Chatooly detection
            renderer.domElement.id = 'chatooly-canvas';
            
            // Add renderer to container
            const container = document.getElementById('threejs-container');
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Create initial spheres
            createInitialSpheres();
            
            // Start render loop
            animate();
            
            updateStatus('‚úÖ Three.js scene initialized');
        }
        
        function createInitialSpheres() {
            const colors = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0x6c5ce7, 0xa55eea];
            
            for (let i = 0; i < 6; i++) {
                const geometry = new THREE.SphereGeometry(0.5 + Math.random() * 0.5, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: colors[i],
                    shininess: 100,
                    specular: 0x222222
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                
                sphere.castShadow = true;
                sphere.receiveShadow = true;
                
                // Add random rotation speeds
                sphere.userData = {
                    rotationSpeed: {
                        x: (Math.random() - 0.5) * 0.02,
                        y: (Math.random() - 0.5) * 0.02,
                        z: (Math.random() - 0.5) * 0.02
                    },
                    orbitRadius: 2 + Math.random() * 3,
                    orbitSpeed: (Math.random() - 0.5) * 0.01,
                    originalPosition: sphere.position.clone()
                };
                
                spheres.push(sphere);
                scene.add(sphere);
            }
        }
        
        function animate() {
            if (!animationRunning) return;
            
            time += 0.01;
            
            // Animate spheres
            spheres.forEach((sphere, index) => {
                const userData = sphere.userData;
                
                // Rotation
                sphere.rotation.x += userData.rotationSpeed.x;
                sphere.rotation.y += userData.rotationSpeed.y;
                sphere.rotation.z += userData.rotationSpeed.z;
                
                // Orbital motion
                const angle = time * userData.orbitSpeed + index;
                sphere.position.x = userData.originalPosition.x + Math.cos(angle) * userData.orbitRadius;
                sphere.position.y = userData.originalPosition.y + Math.sin(angle * 0.7) * userData.orbitRadius * 0.5;
                sphere.position.z = userData.originalPosition.z + Math.sin(angle * 1.3) * userData.orbitRadius * 0.3;
                
                // Pulsing scale
                const scale = 1 + Math.sin(time * 2 + index) * 0.2;
                sphere.scale.setScalar(scale);
            });
            
            // Camera orbit
            camera.position.x = Math.cos(time * 0.3) * 15;
            camera.position.y = Math.sin(time * 0.2) * 5;
            camera.position.z = Math.sin(time * 0.3) * 15;
            camera.lookAt(scene.position);
            
            // Render
            renderer.render(scene, camera);
            
            animationId = requestAnimationFrame(animate);
        }
        
        function toggleAnimation() {
            animationRunning = !animationRunning;
            if (animationRunning) {
                updateStatus('üåü Three.js animation resumed');
                animate();
            } else {
                updateStatus('‚è∏Ô∏è Three.js animation paused');
                cancelAnimationFrame(animationId);
            }
        }
        
        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            spheres.forEach(sphere => {
                sphere.material.wireframe = wireframeMode;
            });
            updateStatus(`üìê Wireframe mode: ${wireframeMode ? 'ON' : 'OFF'}`);
        }
        
        function addSphere() {
            const colors = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0x6c5ce7, 0xa55eea];
            const geometry = new THREE.SphereGeometry(0.3 + Math.random() * 0.4, 12, 12);
            const material = new THREE.MeshPhongMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                shininess: 100,
                specular: 0x222222,
                wireframe: wireframeMode
            });
            
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(
                (Math.random() - 0.5) * 8,
                (Math.random() - 0.5) * 8,
                (Math.random() - 0.5) * 8
            );
            
            sphere.castShadow = true;
            sphere.receiveShadow = true;
            
            sphere.userData = {
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.03,
                    y: (Math.random() - 0.5) * 0.03,
                    z: (Math.random() - 0.5) * 0.03
                },
                orbitRadius: 1 + Math.random() * 2,
                orbitSpeed: (Math.random() - 0.5) * 0.02,
                originalPosition: sphere.position.clone()
            };
            
            spheres.push(sphere);
            scene.add(sphere);
            
            updateStatus(`‚ûï Added sphere (Total: ${spheres.length})`);
        }
        
        function testDetection() {
            updateStatus('üîç Testing Three.js animation detection...');
            
            if (!window.Chatooly || !window.Chatooly.animation) {
                updateStatus('‚ùå Chatooly animation module not loaded');
                return;
            }
            
            const toolInfo = window.Chatooly.animation.detectToolType();
            console.log('üîç Detection result:', toolInfo);
            
            if (toolInfo.type === 'animated') {
                updateStatus(`‚úÖ Animation detected: ${toolInfo.framework} framework`);
                console.log('üìä Three.js globals found:', {
                    'window.THREE': !!window.THREE,
                    'renderer': !!renderer,
                    'scene': !!scene,
                    'canvas_id': document.getElementById('chatooly-canvas') ? 'found' : 'missing'
                });
            } else {
                updateStatus('‚ùå No animation detected - check console for details');
            }
        }
        
        function testExport() {
            if (!window.Chatooly || !window.Chatooly.animation) {
                updateStatus('‚ùå Chatooly animation module not available');
                return;
            }
            
            updateStatus('üé• Opening Three.js export dialog...');
            
            // Ensure animation is running
            if (!animationRunning) {
                toggleAnimation();
            }
            
            // Show export dialog
            setTimeout(() => {
                window.Chatooly.animation.showExportDialog();
            }, 500);
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
        
        // Initialize when libraries are loaded
        setTimeout(() => {
            if (window.THREE) {
                initThreeJS();
                
                setTimeout(() => {
                    if (window.Chatooly && window.Chatooly.animation) {
                        updateStatus('‚úÖ Chatooly CDN loaded - Three.js test ready');
                        testDetection();
                    } else {
                        updateStatus('‚ö†Ô∏è Waiting for Chatooly CDN to load...');
                        setTimeout(() => {
                            if (window.Chatooly && window.Chatooly.animation) {
                                updateStatus('‚úÖ Chatooly CDN loaded - Three.js test ready');
                                testDetection();
                            } else {
                                updateStatus('‚ùå Chatooly CDN failed to load');
                            }
                        }, 2000);
                    }
                }, 1000);
            } else {
                updateStatus('‚ùå Three.js failed to load');
            }
        }, 1000);
        
        // Time control for recording (optional)
        window.setAnimationTime = function(recordingTime) {
            time = recordingTime * 2; // Speed control during recording
        };
    </script>
</body>
</html>