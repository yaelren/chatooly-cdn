<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chatooly CDN - Comprehensive Test Suite</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: #f5f5f5;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        .version-selector {
            background: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }
        .test-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .test-section {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            background: #f8f9fa;
        }
        .test-section h3 {
            margin-top: 0;
            color: #495057;
        }
        .test-element {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
        }
        .results-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
        }
        .log-entry {
            margin: 5px 0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
        }
        .log-success { color: #28a745; }
        .log-error { color: #dc3545; }
        .log-info { color: #007bff; }
        .log-warn { color: #ffc107; }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 2px;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-pass { background: #28a745; }
        .status-fail { background: #dc3545; }
        .status-pending { background: #ffc107; }
        .status-running { background: #007bff; animation: pulse 1s infinite; }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        #test-canvas { border: 1px solid #ccc; }
        .gradient-test {
            width: 200px;
            height: 120px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        
        .export-gallery {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }
        .export-preview {
            width: 100px;
            height: 75px;
            border: 1px solid #ccc;
            border-radius: 4px;
            object-fit: cover;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ Chatooly CDN Comprehensive Test Suite</h1>
        <p>This test suite validates all functionality of the Chatooly CDN library across different scenarios and configurations.</p>
        
        <div class="version-selector">
            <strong>CDN Version:</strong>
            <label style="margin: 0 10px;">
                <input type="radio" name="version" value="full" checked onchange="switchVersion(this.value)"> 
                Full (20KB)
            </label>
            <label style="margin: 0 10px;">
                <input type="radio" name="version" value="min" onchange="switchVersion(this.value)"> 
                Minified (9.8KB)
            </label>
            <span id="current-version" style="margin-left: 20px; font-weight: bold; color: #007bff;">Using: Full</span>
        </div>
        
        <div class="test-controls">
            <button onclick="runAllTests()">üöÄ Run All Tests</button>
            <button onclick="runCanvasTests()">üé® Canvas Tests</button>
            <button onclick="runDOMTests()">üìÑ DOM Tests</button>
            <button onclick="runResolutionTests()">üìê Resolution Tests</button>
            <button onclick="runPublishTests()">üì§ Publish Tests</button>
            <button onclick="runPerformanceTests()">‚ö° Performance Tests</button>
            <button onclick="clearResults()">üóëÔ∏è Clear Results</button>
            <button onclick="exportTestReport()">üíæ Export Report</button>
        </div>
        
        <div class="test-grid">
            <!-- Canvas Tests -->
            <div class="test-section">
                <h3><span class="status-indicator status-pending" id="canvas-status"></span>Canvas Export Tests</h3>
                
                <div class="test-element">
                    <h4>HTML5 Canvas</h4>
                    <canvas id="test-canvas" width="200" height="150"></canvas>
                    <div>
                        <button onclick="testCanvasExport('html5', 1)">1x</button>
                        <button onclick="testCanvasExport('html5', 2)">2x</button>
                        <button onclick="testCanvasExport('html5', 4)">4x</button>
                    </div>
                </div>
                
                <div class="test-element">
                    <h4>p5.js Canvas (Simulated)</h4>
                    <canvas id="p5-canvas" width="200" height="150"></canvas>
                    <div>
                        <button onclick="testCanvasExport('p5', 1)">1x</button>
                        <button onclick="testCanvasExport('p5', 2)">2x</button>
                        <button onclick="testCanvasExport('p5', 4)">4x</button>
                    </div>
                </div>
                
                <div class="test-element">
                    <h4>Three.js Canvas (Simulated)</h4>
                    <canvas id="three-canvas" width="200" height="150"></canvas>
                    <div>
                        <button onclick="testCanvasExport('three', 1)">1x</button>
                        <button onclick="testCanvasExport('three', 2)">2x</button>
                        <button onclick="testCanvasExport('three', 4)">4x</button>
                    </div>
                </div>
            </div>
            
            <!-- DOM Tests -->
            <div class="test-section">
                <h3><span class="status-indicator status-pending" id="dom-status"></span>DOM Export Tests</h3>
                
                <div class="test-element">
                    <h4>CSS Gradient</h4>
                    <div id="gradient-display" class="gradient-test">Gradient Test</div>
                    <div>
                        <button onclick="testDOMExport('gradient', 1)">1x</button>
                        <button onclick="testDOMExport('gradient', 2)">2x</button>
                        <button onclick="testDOMExport('gradient', 4)">4x</button>
                    </div>
                </div>
                
                <div class="test-element">
                    <h4>Complex DOM Element</h4>
                    <div id="complex-dom" style="width: 200px; height: 120px; background: white; border: 2px solid #007bff; border-radius: 8px; padding: 10px;">
                        <h5 style="margin: 0; color: #007bff;">Complex Element</h5>
                        <p style="margin: 5px 0; font-size: 12px;">With text, borders, and styling</p>
                        <div style="display: flex; gap: 5px;">
                            <div style="width: 20px; height: 20px; background: #ff6b6b; border-radius: 50%;"></div>
                            <div style="width: 20px; height: 20px; background: #4ecdc4; border-radius: 50%;"></div>
                            <div style="width: 20px; height: 20px; background: #45b7d1; border-radius: 50%;"></div>
                        </div>
                    </div>
                    <div>
                        <button onclick="testDOMExport('complex', 1)">1x</button>
                        <button onclick="testDOMExport('complex', 2)">2x</button>
                        <button onclick="testDOMExport('complex', 4)">4x</button>
                    </div>
                </div>
            </div>
            
            <!-- Library Tests -->
            <div class="test-section">
                <h3><span class="status-indicator status-pending" id="library-status"></span>Library Function Tests</h3>
                
                <div class="test-element">
                    <h4>Initialization</h4>
                    <button onclick="testInitialization()">Test Init</button>
                    <button onclick="testReinitialization()">Test Re-init</button>
                </div>
                
                <div class="test-element">
                    <h4>Export Target Detection</h4>
                    <button onclick="testTargetDetection()">Test Detection</button>
                    <button onclick="testTargetPriority()">Test Priority</button>
                </div>
                
                <div class="test-element">
                    <h4>Configuration</h4>
                    <button onclick="testConfiguration()">Test Config</button>
                    <button onclick="testCustomConfig()">Custom Config</button>
                </div>
                
                <div class="test-element">
                    <h4>Development Mode</h4>
                    <button onclick="testDevMode()">Test Dev Mode</button>
                    <button onclick="testPublishUI()">Test Publish UI</button>
                </div>
            </div>
            
            <!-- Performance Tests -->
            <div class="test-section">
                <h3><span class="status-indicator status-pending" id="performance-status"></span>Performance Tests</h3>
                
                <div class="test-element">
                    <h4>Loading Performance</h4>
                    <div id="load-times"></div>
                    <button onclick="measureLoadTime()">Measure Load</button>
                </div>
                
                <div class="test-element">
                    <h4>Export Performance</h4>
                    <div id="export-times"></div>
                    <button onclick="measureExportTime()">Measure Export</button>
                </div>
                
                <div class="test-element">
                    <h4>Memory Usage</h4>
                    <div id="memory-usage"></div>
                    <button onclick="measureMemory()">Check Memory</button>
                </div>
                
                <div class="test-element">
                    <h4>Stress Test</h4>
                    <div id="stress-results"></div>
                    <button onclick="runStressTest()">Run Stress Test</button>
                </div>
            </div>
        </div>
        
        <div class="results-panel">
            <h3>Test Results</h3>
            <div id="test-log"></div>
        </div>
        
        <div class="test-section">
            <h3>Export Gallery</h3>
            <p>Generated exports will appear here:</p>
            <div id="export-gallery" class="export-gallery"></div>
        </div>
    </div>

    <!-- Include libraries for simulation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Chatooly CDN - Dynamic Loading -->
    <script id="chatooly-script" src="../js/core.js"></script>
    
    <!-- Tool Configuration -->
    <script>
        window.ChatoolyConfig = {
            name: "Comprehensive Test Suite",
            resolution: 2
        };
    </script>
    
    <!-- Comprehensive Test Suite -->
    <script>
        const testResults = {
            canvasTests: {},
            domTests: {},
            libraryTests: {},
            performanceTests: {},
            summary: {
                total: 0,
                passed: 0,
                failed: 0,
                errors: []
            }
        };
        
        let testRunning = false;
        
        // Logging functions
        function log(message, type = 'info') {
            const logDiv = document.getElementById('test-log');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.innerHTML = `<span>[${timestamp}]</span> ${message}`;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[Test] ${message}`);
        }
        
        function updateStatus(section, status) {
            const indicator = document.getElementById(`${section}-status`);
            if (indicator) {
                indicator.className = `status-indicator status-${status}`;
            }
        }
        
        // Version switching
        function switchVersion(version) {
            const oldScript = document.getElementById('chatooly-script');
            const newScript = document.createElement('script');
            
            newScript.id = 'chatooly-script';
            newScript.src = version === 'min' ? '../js/core.min.js' : '../js/core.js';
            
            document.getElementById('current-version').textContent = 
                `Using: ${version === 'min' ? 'Minified (9.8KB)' : 'Full (20KB)'}`;
            
            oldScript.parentNode.insertBefore(newScript, oldScript);
            oldScript.remove();
            
            newScript.onload = () => {
                if (window.Chatooly) {
                    window.Chatooly.init(window.ChatoolyConfig);
                    log(`Switched to ${version === 'min' ? 'minified' : 'full'} version`, 'info');
                }
            };
        }
        
        // Canvas drawing functions
        function drawTestCanvas(canvasId, type = 'html5') {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.error(`Canvas not found: ${canvasId}`);
                return;
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error(`Could not get 2D context for canvas: ${canvasId}`);
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Simulate different drawing styles based on type
            if (type === 'p5') {
                // Simulate p5.js style - DON'T change the actual canvas ID
                const originalId = canvas.id;
                
                // Set up p5.js simulation globals
                window.p5 = true; // Simulate p5.js presence
                window.pixelDensity = (density) => {
                    if (density !== undefined) {
                        window._currentPixelDensity = density;
                    }
                    return window._currentPixelDensity || 1;
                };
                window.redraw = () => {
                    // Redraw on the same canvas, don't change ID
                    const redrawCanvas = document.getElementById(originalId);
                    if (redrawCanvas) {
                        const redrawCtx = redrawCanvas.getContext('2d');
                        redrawCtx.clearRect(0, 0, redrawCanvas.width, redrawCanvas.height);
                        
                        // Draw p5.js-style content
                        redrawCtx.fillStyle = '#ff6b6b';
                        redrawCtx.fillRect(0, 0, redrawCanvas.width, redrawCanvas.height);
                        redrawCtx.fillStyle = 'white';
                        redrawCtx.font = '16px Arial';
                        redrawCtx.textAlign = 'center';
                        redrawCtx.fillText('p5.js Test', redrawCanvas.width/2, redrawCanvas.height/2);
                        
                        // Animated circle
                        const time = Date.now() * 0.001;
                        redrawCtx.beginPath();
                        redrawCtx.arc(redrawCanvas.width/2 + Math.cos(time) * 30, redrawCanvas.height/2 + Math.sin(time) * 20, 15, 0, Math.PI * 2);
                        redrawCtx.fillStyle = '#4ecdc4';
                        redrawCtx.fill();
                    }
                };
                
                // Draw p5.js-style content
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('p5.js Test', canvas.width/2, canvas.height/2);
                
                // Animated circle
                const time = Date.now() * 0.001;
                ctx.beginPath();
                ctx.arc(canvas.width/2 + Math.cos(time) * 30, canvas.height/2 + Math.sin(time) * 20, 15, 0, Math.PI * 2);
                ctx.fillStyle = '#4ecdc4';
                ctx.fill();
                
            } else if (type === 'three') {
                // Simulate Three.js
                window.THREE = { Vector2: function() { return { x: 200, y: 150 }; } };
                window.renderer = {
                    getSize: () => ({ x: canvas.width, y: canvas.height }),
                    getClearColor: () => 0x222222,
                    getClearAlpha: () => 1
                };
                window.scene = {};
                window.camera = {};
                
                // Draw Three.js-style content
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, '#222222');
                gradient.addColorStop(1, '#444444');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw 3D-looking cube
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(50, 40, 60, 60);
                ctx.fillStyle = '#ff8b8b';
                ctx.fillRect(110, 40, 20, 60);
                ctx.fillStyle = '#ff4b4b';
                ctx.fillRect(50, 20, 60, 20);
                
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Three.js Test', canvas.width/2, canvas.height - 20);
                
            } else {
                // Regular HTML5 canvas
                const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, Math.min(canvas.width, canvas.height)/2);
                gradient.addColorStop(0, '#ff6b6b');
                gradient.addColorStop(1, '#4ecdc4');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('HTML5 Canvas', canvas.width/2, canvas.height/2);
                
                // Draw some shapes
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.arc(40 + i * 30, 30, 10, 0, Math.PI * 2);
                    ctx.fillStyle = `hsl(${i * 60}, 70%, 60%)`;
                    ctx.fill();
                }
            }
        }
        
        // Canvas export tests
        async function testCanvasExport(type, resolution) {
            updateStatus('canvas', 'running');
            const canvasId = type === 'html5' ? 'test-canvas' : type === 'p5' ? 'p5-canvas' : 'three-canvas';
            
            try {
                drawTestCanvas(canvasId, type);
                
                // Create a promise that resolves when export completes
                const exportPromise = new Promise((resolve, reject) => {
                    const startTime = performance.now();
                    
                    // Get canvas element
                    const canvasElement = document.getElementById(canvasId);
                    if (!canvasElement) {
                        reject(new Error(`Canvas element not found: ${canvasId}`));
                        return;
                    }
                    
                    // Store original ID before any changes
                    const originalCanvasId = canvasElement.id;
                    
                    // For p5.js simulation, also set up the canvas detection
                    if (type === 'p5') {
                        canvasElement.id = 'defaultCanvas0'; // Temporarily set p5.js ID for detection
                    }
                    
                    // Override export target detection for this test
                    const originalDetection = window.Chatooly._detectExportTarget;
                    window.Chatooly._detectExportTarget = () => ({
                        type: 'canvas',
                        element: canvasElement
                    });
                    
                    // Simulate export (we can't actually download in tests)
                    const originalDownload = window.Chatooly._downloadImage;
                    
                    window.Chatooly._downloadImage = (dataURL, filename) => {
                        const exportTime = performance.now() - startTime;
                        
                        // Clear timeout and restore original functions
                        clearTimeout(timeout);
                        window.Chatooly._detectExportTarget = originalDetection;
                        window.Chatooly._downloadImage = originalDownload;
                        
                        // Restore original canvas ID
                        canvasElement.id = originalCanvasId;
                        
                        addExportToGallery(dataURL, `${type}-${resolution}x`);
                        log(`Export completed: ${filename} (${exportTime.toFixed(2)}ms)`, 'success');
                        
                        resolve({
                            success: true,
                            exportTime: exportTime,
                            resolution: resolution,
                            dataURL: dataURL
                        });
                    };
                    
                    // Set timeout in case export fails silently
                    const timeout = setTimeout(() => {
                        window.Chatooly._detectExportTarget = originalDetection;
                        window.Chatooly._downloadImage = originalDownload;
                        
                        // Restore original canvas ID
                        canvasElement.id = originalCanvasId;
                        
                        reject(new Error('Export timeout'));
                    }, 5000);
                    
                    try {
                        // Trigger export
                        window.Chatooly.export('png', { resolution: resolution });
                    } catch (error) {
                        clearTimeout(timeout);
                        window.Chatooly._detectExportTarget = originalDetection;
                        window.Chatooly._downloadImage = originalDownload;
                        
                        // Restore original canvas ID
                        canvasElement.id = originalCanvasId;
                        
                        reject(error);
                    }
                });
                
                // Wait for export to complete
                const result = await exportPromise;
                
                testResults.canvasTests[`${type}_${resolution}x`] = result;
                log(`‚úÖ ${type} ${resolution}x export: ${result.exportTime.toFixed(2)}ms`, 'success');
                updateStatus('canvas', 'pass');
                
            } catch (error) {
                testResults.canvasTests[`${type}_${resolution}x`] = {
                    success: false,
                    error: error.message
                };
                log(`‚ùå ${type} ${resolution}x export failed: ${error.message}`, 'error');
                updateStatus('canvas', 'fail');
            }
        }
        
        // DOM export tests
        async function testDOMExport(elementType, resolution) {
            updateStatus('dom', 'running');
            
            try {
                const startTime = performance.now();
                const elementId = elementType === 'gradient' ? 'gradient-display' : 'complex-dom';
                
                // Override export target detection
                const originalDetection = window.Chatooly._detectExportTarget;
                window.Chatooly._detectExportTarget = () => ({
                    type: 'dom',
                    element: document.getElementById(elementId)
                });
                
                // Simulate export
                const originalDownload = window.Chatooly._downloadImage;
                let exportSuccess = false;
                window.Chatooly._downloadImage = (dataURL, filename) => {
                    exportSuccess = true;
                    addExportToGallery(dataURL, `${elementType}-${resolution}x`);
                    log(`DOM export completed: ${filename}`, 'success');
                };
                
                // Trigger export
                window.Chatooly.export('png', { resolution: resolution });
                
                // Wait a bit for html2canvas to load if needed
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                const exportTime = performance.now() - startTime;
                
                // Restore original functions
                window.Chatooly._detectExportTarget = originalDetection;
                window.Chatooly._downloadImage = originalDownload;
                
                if (exportSuccess) {
                    testResults.domTests[`${elementType}_${resolution}x`] = {
                        success: true,
                        exportTime: exportTime,
                        resolution: resolution
                    };
                    log(`‚úÖ DOM ${elementType} ${resolution}x export: ${exportTime.toFixed(2)}ms`, 'success');
                    updateStatus('dom', 'pass');
                } else {
                    throw new Error('DOM export failed');
                }
                
            } catch (error) {
                testResults.domTests[`${elementType}_${resolution}x`] = {
                    success: false,
                    error: error.message
                };
                log(`‚ùå DOM ${elementType} ${resolution}x export failed: ${error.message}`, 'error');
                updateStatus('dom', 'fail');
            }
        }
        
        // Library function tests
        function testInitialization() {
            try {
                const originalConfig = { ...window.Chatooly.config };
                window.Chatooly.init({ name: 'Test Tool', resolution: 4 });
                
                if (window.Chatooly.config.name === 'Test Tool' && window.Chatooly.config.resolution === 4) {
                    log('‚úÖ Initialization test passed', 'success');
                    testResults.libraryTests.initialization = { success: true };
                } else {
                    throw new Error('Configuration not applied correctly');
                }
            } catch (error) {
                log(`‚ùå Initialization test failed: ${error.message}`, 'error');
                testResults.libraryTests.initialization = { success: false, error: error.message };
            }
        }
        
        function testReinitialization() {
            try {
                window.Chatooly.init({ name: 'Reinit Test', resolution: 1 });
                window.Chatooly.init({ name: 'Reinit Test 2', resolution: 3 });
                
                if (window.Chatooly.config.name === 'Reinit Test 2' && window.Chatooly.config.resolution === 3) {
                    log('‚úÖ Re-initialization test passed', 'success');
                    testResults.libraryTests.reinitialization = { success: true };
                } else {
                    throw new Error('Re-initialization failed');
                }
            } catch (error) {
                log(`‚ùå Re-initialization test failed: ${error.message}`, 'error');
                testResults.libraryTests.reinitialization = { success: false, error: error.message };
            }
        }
        
        function testConfiguration() {
            try {
                const config = {
                    name: 'Config Test',
                    resolution: 4,
                    exportFormats: ['png'],
                    buttonPosition: 'bottom-right'
                };
                
                window.Chatooly.init(config);
                
                const configMatch = Object.keys(config).every(key => 
                    window.Chatooly.config[key] === config[key] || 
                    JSON.stringify(window.Chatooly.config[key]) === JSON.stringify(config[key])
                );
                
                if (configMatch) {
                    log('‚úÖ Configuration test passed', 'success');
                    testResults.libraryTests.configuration = { success: true };
                } else {
                    throw new Error('Configuration not applied correctly');
                }
            } catch (error) {
                log(`‚ùå Configuration test failed: ${error.message}`, 'error');
                testResults.libraryTests.configuration = { success: false, error: error.message };
            }
        }
        
        function testCustomConfig() {
            try {
                const customConfig = { name: 'Custom Test', resolution: 8 };
                window.Chatooly.init(customConfig);
                
                if (window.Chatooly.config.name === 'Custom Test' && window.Chatooly.config.resolution === 8) {
                    log('‚úÖ Custom configuration test passed', 'success');
                    testResults.libraryTests.customConfig = { success: true };
                } else {
                    throw new Error('Custom configuration not applied');
                }
            } catch (error) {
                log(`‚ùå Custom configuration test failed: ${error.message}`, 'error');
                testResults.libraryTests.customConfig = { success: false, error: error.message };
            }
        }
        
        function testTargetPriority() {
            try {
                // Test that gradient-display is detected with priority
                const target = window.Chatooly._detectExportTarget();
                
                if (target.element.id === 'gradient-display') {
                    log('‚úÖ Target priority test passed - gradient-display detected first', 'success');
                    testResults.libraryTests.targetPriority = { success: true, detectedId: target.element.id };
                } else {
                    log(`‚ö†Ô∏è Target priority test - detected ${target.element.tagName}#${target.element.id}`, 'warn');
                    testResults.libraryTests.targetPriority = { success: true, detectedId: target.element.id, note: 'Different element detected' };
                }
            } catch (error) {
                log(`‚ùå Target priority test failed: ${error.message}`, 'error');
                testResults.libraryTests.targetPriority = { success: false, error: error.message };
            }
        }
        
        function testPublishUI() {
            try {
                const isDev = window.Chatooly._isDevelopment();
                const publishButton = document.querySelector('button[onclick*="publish"]');
                
                if (isDev && publishButton) {
                    log('‚úÖ Publish UI test passed - button found in dev mode', 'success');
                    testResults.libraryTests.publishUI = { success: true, hasButton: true };
                } else if (!isDev) {
                    log('‚ÑπÔ∏è Publish UI test - not in dev mode, publish button hidden', 'info');
                    testResults.libraryTests.publishUI = { success: true, hasButton: false, reason: 'Not in dev mode' };
                } else {
                    throw new Error('Publish button not found in dev mode');
                }
            } catch (error) {
                log(`‚ùå Publish UI test failed: ${error.message}`, 'error');
                testResults.libraryTests.publishUI = { success: false, error: error.message };
            }
        }
        
        function measureMemory() {
            try {
                const memoryInfo = {
                    deviceMemory: navigator.deviceMemory || 'unknown',
                    jsHeapSizeLimit: performance.memory ? (performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2) + 'MB' : 'unknown',
                    totalJSHeapSize: performance.memory ? (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2) + 'MB' : 'unknown',
                    usedJSHeapSize: performance.memory ? (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2) + 'MB' : 'unknown'
                };
                
                document.getElementById('memory-usage').innerHTML = `
                    Device Memory: ${memoryInfo.deviceMemory}GB<br>
                    JS Heap Limit: ${memoryInfo.jsHeapSizeLimit}<br>
                    Total Heap: ${memoryInfo.totalJSHeapSize}<br>
                    Used Heap: ${memoryInfo.usedJSHeapSize}
                `;
                
                log('üìä Memory usage measured', 'info');
                testResults.performanceTests.memoryUsage = memoryInfo;
                
            } catch (error) {
                document.getElementById('memory-usage').textContent = `Error: ${error.message}`;
                log(`‚ùå Memory measurement failed: ${error.message}`, 'error');
            }
        }
        
        async function measureExportTime() {
            try {
                drawTestCanvas('test-canvas', 'html5');
                const canvas = document.getElementById('test-canvas');
                
                const times = [];
                const iterations = 5;
                
                for (let i = 0; i < iterations; i++) {
                    const startTime = performance.now();
                    const dataURL = canvas.toDataURL('image/png');
                    const endTime = performance.now();
                    times.push(endTime - startTime);
                }
                
                const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
                const minTime = Math.min(...times);
                const maxTime = Math.max(...times);
                
                document.getElementById('export-times').innerHTML = `
                    Average: ${avgTime.toFixed(2)}ms<br>
                    Min: ${minTime.toFixed(2)}ms<br>
                    Max: ${maxTime.toFixed(2)}ms<br>
                    Iterations: ${iterations}
                `;
                
                log(`üìä Export performance: ${avgTime.toFixed(2)}ms average`, 'info');
                testResults.performanceTests.exportPerformance = { avgTime, minTime, maxTime, iterations };
                
            } catch (error) {
                document.getElementById('export-times').textContent = `Error: ${error.message}`;
                log(`‚ùå Export performance test failed: ${error.message}`, 'error');
            }
        }
        
        function testTargetDetection() {
            try {
                const target = window.Chatooly._detectExportTarget();
                
                if (target && target.element && target.type) {
                    log(`‚úÖ Target detection: ${target.type} element found`, 'success');
                    testResults.libraryTests.targetDetection = { 
                        success: true, 
                        targetType: target.type,
                        elementTag: target.element.tagName
                    };
                } else {
                    throw new Error('No valid target detected');
                }
            } catch (error) {
                log(`‚ùå Target detection failed: ${error.message}`, 'error');
                testResults.libraryTests.targetDetection = { success: false, error: error.message };
            }
        }
        
        function testDevMode() {
            try {
                const isDev = window.Chatooly._isDevelopment();
                log(`‚úÖ Development mode: ${isDev ? 'enabled' : 'disabled'}`, 'success');
                testResults.libraryTests.devMode = { success: true, isDevelopment: isDev };
            } catch (error) {
                log(`‚ùå Dev mode test failed: ${error.message}`, 'error');
                testResults.libraryTests.devMode = { success: false, error: error.message };
            }
        }
        
        // Performance tests
        async function measureLoadTime() {
            const startTime = performance.now();
            
            // Simulate reload
            if (window.Chatooly) {
                window.Chatooly.init(window.ChatoolyConfig);
            }
            
            const loadTime = performance.now() - startTime;
            document.getElementById('load-times').textContent = `Load time: ${loadTime.toFixed(2)}ms`;
            log(`üìä Library load time: ${loadTime.toFixed(2)}ms`, 'info');
            
            testResults.performanceTests.loadTime = loadTime;
        }
        
        async function runStressTest() {
            updateStatus('performance', 'running');
            const stressResults = document.getElementById('stress-results');
            stressResults.textContent = 'Running stress test...';
            
            try {
                const iterations = 10;
                const times = [];
                
                for (let i = 0; i < iterations; i++) {
                    const startTime = performance.now();
                    
                    // Stress test: rapid canvas redraws and exports
                    drawTestCanvas('test-canvas', 'html5');
                    
                    // Simulate rapid export calls
                    const canvas = document.getElementById('test-canvas');
                    const dataURL = canvas.toDataURL('image/png');
                    
                    const endTime = performance.now();
                    times.push(endTime - startTime);
                    
                    stressResults.textContent = `Stress test: ${i + 1}/${iterations}`;
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                
                const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
                const maxTime = Math.max(...times);
                const minTime = Math.min(...times);
                
                stressResults.innerHTML = `
                    Stress test complete:<br>
                    Average: ${avgTime.toFixed(2)}ms<br>
                    Min: ${minTime.toFixed(2)}ms<br>
                    Max: ${maxTime.toFixed(2)}ms
                `;
                
                testResults.performanceTests.stressTest = {
                    success: true,
                    avgTime,
                    minTime,
                    maxTime,
                    iterations
                };
                
                log(`‚úÖ Stress test completed: ${avgTime.toFixed(2)}ms average`, 'success');
                updateStatus('performance', 'pass');
                
            } catch (error) {
                stressResults.textContent = `Stress test failed: ${error.message}`;
                log(`‚ùå Stress test failed: ${error.message}`, 'error');
                updateStatus('performance', 'fail');
            }
        }
        
        // Utility functions
        function addExportToGallery(dataURL, label) {
            const gallery = document.getElementById('export-gallery');
            const img = document.createElement('img');
            img.src = dataURL;
            img.className = 'export-preview';
            img.title = label;
            img.alt = label;
            gallery.appendChild(img);
        }
        
        function clearResults() {
            document.getElementById('test-log').innerHTML = '';
            document.getElementById('export-gallery').innerHTML = '';
            
            // Reset status indicators
            ['canvas', 'dom', 'library', 'performance'].forEach(section => {
                updateStatus(section, 'pending');
            });
            
            // Clear test results
            Object.keys(testResults).forEach(key => {
                if (typeof testResults[key] === 'object') {
                    testResults[key] = {};
                }
            });
            
            log('üóëÔ∏è Test results cleared', 'info');
        }
        
        // Main test runners
        async function runCanvasTests() {
            log('üé® Starting canvas tests...', 'info');
            
            // Test all canvas types and resolutions
            const canvasTypes = ['html5', 'p5', 'three'];
            const resolutions = [1, 2, 4];
            
            for (const type of canvasTypes) {
                for (const resolution of resolutions) {
                    await testCanvasExport(type, resolution);
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            }
            
            log('üé® Canvas tests completed', 'info');
        }
        
        async function runDOMTests() {
            log('üìÑ Starting DOM tests...', 'info');
            
            const elementTypes = ['gradient', 'complex'];
            const resolutions = [1, 2, 4];
            
            for (const type of elementTypes) {
                for (const resolution of resolutions) {
                    await testDOMExport(type, resolution);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
            
            log('üìÑ DOM tests completed', 'info');
        }
        
        async function runLibraryTests() {
            log('‚öôÔ∏è Starting library tests...', 'info');
            updateStatus('library', 'running');
            
            testInitialization();
            await new Promise(resolve => setTimeout(resolve, 100));
            
            testTargetDetection();
            await new Promise(resolve => setTimeout(resolve, 100));
            
            testDevMode();
            
            updateStatus('library', 'pass');
            log('‚öôÔ∏è Library tests completed', 'info');
        }
        
        async function runPerformanceTests() {
            log('‚ö° Starting performance tests...', 'info');
            
            await measureLoadTime();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await runStressTest();
            
            log('‚ö° Performance tests completed', 'info');
        }
        
        async function runAllTests() {
            if (testRunning) {
                log('‚ö†Ô∏è Tests already running', 'warn');
                return;
            }
            
            testRunning = true;
            log('üöÄ Starting comprehensive test suite...', 'info');
            
            try {
                await runLibraryTests();
                await runCanvasTests();
                await runDOMTests();
                await runPerformanceTests();
                
                // Generate summary
                const summary = generateTestSummary();
                log(`üìã Test Summary: ${summary.passed}/${summary.total} tests passed`, 
                    summary.passed === summary.total ? 'success' : 'warn');
                
            } catch (error) {
                log(`‚ùå Test suite failed: ${error.message}`, 'error');
            } finally {
                testRunning = false;
            }
        }
        
        function generateTestSummary() {
            let total = 0;
            let passed = 0;
            
            Object.values(testResults).forEach(section => {
                if (typeof section === 'object' && section !== testResults.summary) {
                    Object.values(section).forEach(test => {
                        if (test.success !== undefined) {
                            total++;
                            if (test.success) passed++;
                        }
                    });
                }
            });
            
            testResults.summary = { total, passed, failed: total - passed };
            return testResults.summary;
        }
        
        function exportTestReport() {
            const report = {
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                testResults: testResults,
                summary: generateTestSummary()
            };
            
            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `chatooly-test-report-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log('üíæ Test report exported', 'success');
        }
        
        // Initialize
        window.addEventListener('load', () => {
            log('üß™ Comprehensive test suite loaded', 'info');
            
            // Draw initial canvases
            drawTestCanvas('test-canvas', 'html5');
            drawTestCanvas('p5-canvas', 'p5');
            drawTestCanvas('three-canvas', 'three');
            
            // Auto-run basic tests after a delay
            setTimeout(() => {
                log('ü§ñ Running basic initialization tests...', 'info');
                runLibraryTests();
            }, 2000);
        });
    </script>
</body>
</html>